#! /usr/bin/env python3

# ebpH --  An eBPF intrusion detection program.
# -------  Monitors system call patterns and detect anomalies.
# Copyright 2019 William Findlay (williamfindlay@cmail.carleton.ca) and
# Anil Somayaji (soma@scs.carleton.ca)
#
# Based on Anil Somayaji's pH
#  http://people.scs.carleton.ca/~mvvelzen/pH/pH.html
#  Copyright 2003 Anil Somayaji
#
# USAGE: ebph <COMMAND>
#
# Licensed under GPL v2 License

import os, sys
import argparse
import subprocess

from ebpH import defs

DESCRIPTION = """
Issue commands to ebpH and make queries about system state.
The ebpH daemon (ebphd) must be running in order to run this software.
"""

EPILOG = """
Example usage:
    sudo ebph-admin start  # Start the daemon
    sudo ebph-admin off    # Pause monitoring
    sudo ebph-admin status # Check system status
"""

EBPHD_PATH = os.path.join(defs.project_path, 'bin/ebphd')
EBPH_PS_PATH = os.path.join(defs.project_path, 'bin/ebph-ps')

commands = {}

def command(operation):
    """
    Register a command that can be invoked via args.
    """
    def decorator(func):
        global commands
        commands[operation] = func
        return func
    return decorator

def parse_args(args=[]):
    parser = argparse.ArgumentParser(description=DESCRIPTION, prog="ebph-admin", epilog=EPILOG,
            formatter_class=argparse.RawDescriptionHelpFormatter)

    commands = parser.add_subparsers(title="possible commands", dest="command", required=1, metavar='COMMAND')
    start = commands.add_parser('start',
            help="Start the ebpH daemon.")

    restart = commands.add_parser('restart',
            help="Restart the ebpH daemon.")

    stop = commands.add_parser('stop',
            help="Stop the ebpH daemon.")

    on = commands.add_parser('on',
            help="Resume system monitoring.")

    off = commands.add_parser('off',
            help="Pause system monitoring without killing the daemon.")

    save_profiles = commands.add_parser('save',
            help="Save all profiles to disk. (This command only works if the daemon is allowed to save profiles).")

    status = commands.add_parser('status',
            help="Print ebpH status to stdout.")

    ps = commands.add_parser('ps',
            help="Run ebph-ps with the specified flags and arguments.")
    ps_options = ps.add_mutually_exclusive_group()
    ps_options.add_argument('-t', '--threads', action='store_true',
            help=f"Print all threads instead of just thread group leader.")
    ps_options.add_argument('-p', '--profiles', action='store_true',
            help=f"Print all profiles instead of active processes.")

    inspect = commands.add_parser('inspect',
            help="Inspect the profile with key <key>. Use ebph-ps -p to find profile keys.")
    inspect.add_argument('key',
            help="Key of the profile to inspect.")

    normalize = commands.add_parser('normalize',
            help='Start normal mode on process with tid <tid>.')
    normalize.add_argument('tid', type=int,
            help='Thread ID of the process to normalize. Can also be a PID.')

    log_sequences = commands.add_parser('log-sequences',
            help='Should ebpH log new sequences?')
    log_sequences.add_argument('should_log', type=int, choices=[1,0],
            help=' Specify 1 for yes, 0 for no.')

    #reset_profile = commands.add_parser('reset',
    #        help="Reset a profile.")
    #reset_profile.add_argument('key',
    #        help="Profile key that should be reset. You can find this with ebph-ps -p.")

    #delete_profile = commands.add_parser('delete-profile',
    #        help="Delete a profile.")
    #delete_profile.add_argument('key',
    #        help="Profile key that should be deleted. You can find this with ebph-ps -p.")

    args = parser.parse_args(args)

    # check for root
    if not (os.geteuid() == 0):
        parser.error("This script must be run with root privileges! Exiting.")

    return args

if __name__ == "__main__":
    args = parse_args(sys.argv[1:])

    @command('start')
    def start():
        """
        Start the daemon.
        """
        subprocess.run([EBPHD_PATH, 'start'])

    @command('restart')
    def restart():
        subprocess.run([EBPHD_PATH, 'restart'])

    @command('stop')
    def stop():
        """
        Stop the daemon.
        """
        subprocess.run([EBPHD_PATH, 'stop'])

    @command('on')
    def on(res=None):
        """
        Start monitoring the system.
        """
        print('not implemented')

    @command('off')
    def off(res=None):
        """
        Stop monitoring the system.
        """
        print('not implemented')

    @command('save')
    def save_profiles(res=None):
        """
        Force save profiles to disk.
        """
        print('not implemented')

    @command('status')
    def status(res=None):
        """
        Print ebphd status to the console.
        """
        print('not implemented')
        #print(f"{'ITEM':<16s} {'STATUS'}")
        #for k, v in res['message'].items():
        #    print(f"{k:<16s} {v}")

    @command('ps')
    def ps(res=None):
        """
        Invoke ebph-ps with the desired arguments.
        """
        flags = []
        if args.profiles:
            flags.append('-p')
        if args.threads:
            flags.append('-t')
        subprocess.run([EBPH_PS_PATH, *flags])

    @command('inspect')
    def inspect(res=None):
        print('not implemented')

    @command('normalize')
    def normalize(res=None):
        """
        Normalize profile attached to process <tid>.
        """
        print('not implemented')

    @command('log-sequences')
    def log_sequences(res=None):
        """
        Set logging new sequences to 1 or 0.
        """
        print('not implemented')

    # Handle command
    commands[args.command]()
