#! /usr/bin/env python3

# ebpH  An eBPF intrusion detection program. Monitors system call patterns and detect anomalies.
# Copyright 2019 William Findlay (williamfindlay@cmail.carleton.ca) and
# Anil Somayaji (soma@scs.carleton.ca)
#
# Based on Anil Somayaji's pH
#  http://people.scs.carleton.ca/~mvvelzen/pH/pH.html
#  Copyright 2003 Anil Somayaji
#
# Licensed under GPL v2 License

import os, sys
import socket
import argparse
import struct
import datetime
import json

from ebpH.utils import to_json_bytes, from_json_bytes, receive_message, send_message, connect_to_socket
from ebpH import defs

DESCRIPTION = """
List processes/profiles being traced by ebpH.
The ebpH daemon (ebphd) must be running in order to run this software.
"""

EPILOG = """
Example usage:
    sudo ebph-ps --profiles # Lists all profiles known to ebpH
    sudo ebph-ps --threads  # Lists all threads being traced by ebpH
    sudo ebph-ps            # Lists all processes being traced by ebpH
"""

def format_comm(comm):
    return comm if len(comm) < 16 else ''.join([comm[:(16-3)], '...'])

def print_profile_information(profile, header=0):
    comm = format_comm(profile["comm"])
    status = 'Normal' if profile["normal"] else 'Frozen' if profile["frozen"] else 'Training'

    if header:
        print(f"{'KEY':<16} {'COMM':<16} {'STATUS':<12} {'TRAIN_COUNT':>12} {'LAST_MOD':>12} {'ANOMALIES':>12} {'NORMAL TIME':<16}")

    normal_time = datetime.datetime.fromtimestamp(profile['normal_time'] // 1000000000)
    normal_time = normal_time.strftime('%Y-%m-%d %H:%M:%S')

    print(f"{profile['key']:<16} {comm:<16} {status:<12} {profile['train_count']:>12} {profile['last_mod_count']:>12} "
            f"{profile['anomalies']:>12} {normal_time:<16}")

def print_process_information(process, header=0, show_threads=0):
    profile = process["profile"]
    comm = format_comm(profile["comm"])
    status = 'Normal' if profile["normal"] else 'Frozen' if profile["frozen"] else 'Training'

    if header and show_threads:
        print(f"{'PID':<8} {'TID':<8} {'COMM':<16} {'STATUS':<12} {'TRAIN_COUNT':>12} {'LAST_MOD':>12} {'ANOMALIES':>12} {'NORMAL TIME':<16}")
    elif header:
        print(f"{'PID':<8} {'COMM':<16} {'STATUS':<12} {'TRAIN_COUNT':>12} {'LAST_MOD':>12} {'ANOMALIES':>12} {'NORMAL TIME':<16}")

    normal_time = datetime.datetime.fromtimestamp(profile['normal_time'] // 1000000000)
    normal_time = normal_time.strftime('%Y-%m-%d %H:%M:%S')

    if show_threads:
        print(f"{process['pid']:<8} {process['tid']:<8} {comm:<16} {status:<12} {profile['train_count']:>12} {profile['last_mod_count']:>12} "
              f"{profile['anomalies']:>12} {normal_time:<16}")
    else:
        print(f"{process['pid']:<8} {comm:<16} {status:<12} {profile['train_count']:>12} {profile['last_mod_count']:>12} "
              f"{profile['anomalies']:>12} {normal_time:<16}")

def sort_key(args):
    if args.profiles:
        return lambda item: item[1]["comm"]
    elif args.threads:
        return lambda item: (item[1]["pid"], item[1]["tid"])
    else:
        return lambda item: item[1]["pid"]

def parse_args(args=[]):
    parser = argparse.ArgumentParser(description=DESCRIPTION, prog="ebph-ps", epilog=EPILOG,
            formatter_class=argparse.RawDescriptionHelpFormatter)

    options = parser.add_mutually_exclusive_group()
    options.add_argument('-t', '--threads', action='store_true',
            help=f"Print all threads instead of just thread group leader.")
    options.add_argument('-p', '--profiles', action='store_true',
            help=f"Print all profiles instead of active processes.")

    args = parser.parse_args(args)

    # check for root
    if not (os.geteuid() == 0):
        parser.error("This script must be run with root privileges! Exiting.")

    return args


if __name__ == "__main__":
    args = parse_args(sys.argv[1:])

    # Connect to socket
    sock = connect_to_socket()

    # Form request
    request = {'func': 'fetch_profiles' if args.profiles else 'fetch_processes'}

    # Send request
    send_message(sock, to_json_bytes(request))

    # Handle response
    res = receive_message(sock)
    res = from_json_bytes(res)

    items = sorted(res['message'].items(), key=sort_key(args))

    if not args.profiles and not args.threads:
        items = [(k, v) for k, v in items if v["pid"] == v["tid"]]

    # Print output
    header = 1
    for k, v in items:
        if args.profiles:
            print_profile_information(v, header)
        else:
            print_process_information(v, header, args.threads)
        header = 0
    sock.close()
